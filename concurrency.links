#### CONCURRENCY ####
typename Pid(a::Type) = Process({hear: a});

#### SESSION TYPING STUFF ####
# The SessionFail is defined to be a control-flow-linear operation.
# The effect row variable `e` can have kind `Row(Any)` because no linear
# resources are used in this function.
#sig fork : forall s::Session,e::Row.((s) ~e~> ()) ~e~> ~s
sig fork : forall s::Session,e::Row(Any).((s) {SessionFail:() =@ [||]}~> ()) ~e~> ~s
fun fork(f) {
  var ap = new ();
  var _ = spawnAngel {
    f(accept(ap))
  };
  request(ap)
}

#sig linFork : forall s::Session,e::Row.((s) ~e~@ ()) ~e~> ~s
sig linFork : forall s::Session,e::Row . ((s) {SessionFail:() =@ [||]}~@ ()) ~e~> ~s
fun linFork(f) {
  xlin;
  var ap = new();
  var _ = spawnAngel {
    f(accept(ap))
  };
  request(ap)
}

#sig reproduce : forall s::Session,e::Row . (AP(s), (s) ~e~> ()) ~e~> ()
sig reproduce : forall s::Session,e::Row . (AP(s), (s) {SessionFail:() =@ [||]}~> ()) ~e~> ()
fun reproduce(ap, f) {
  xlin;
  var x = accept(ap);
  var _ = spawn {f(x)};
  reproduce(ap, f)
}

# Here we use an additional access point to synchronise on termination
# of communicating threads. This synchronisation can be useful because
# we do not have an explicit close function and by default the
# top-level process does not wait for running threads to terminate.
#
# (In fact, this gymnastics is no longer necessary now that we have
# spawnAngel which allows us to spawn a process that will continue to
# run even if the main process terminates.)

#sig connect : forall s::Session,e::Row,a.((s) ~e~> (), (~s) ~e~> a) ~e~> a
sig connect : forall s::Session,e::Row,a.((s) {SessionFail:() =@ [||]}~> (), (~s) ~e~> a) ~e~> a
fun connect(f, g) {
  xlin;
  var ap = new();
  var done = new();
  var _ = spawn {
    f(accept(ap));
    close(send((), accept(done)))
  };
  var result = g(request(ap));
  var (_, s) = receive(request(done));
  close(s);
  result
}

### sessions with split ends ###
typename EndBang = !().End;
typename EndQuery = ?().End;

sig wait : forall e::Row . (EndQuery) { |e}~> ()
fun wait(s) {
  xlin;
  var (_, s) = receive(s);
  close(s)
}

sig closeBang : forall e::Row . (EndBang) { |e}~> ()
fun closeBang(s) {
  xlin;
  close(send((), s))
}

sig makeEndBang : forall e::Row . () { |e}~> EndBang
fun makeEndBang() {
  xlin;
  var ap = new();
  var _ = spawn {
     var c = accept(ap);
     wait(c)
  };
  request(ap)
}

# with split ends we synchronise on the termination of each spawned
# child process
#sig forkSync : forall s::Session,e::Row.((s) ~e~> EndBang) ~e~> ~s
sig forkSync : forall s::Session,e::Row.((s) {SessionFail:() =@ [||]}~> EndBang) ~e~> ~s
fun forkSync(f) {
  xlin;
  var ap = new();
  var _ = spawn {
    var c = accept(ap);
    var c = f(c);
    closeBang(c)
  };
  request(ap)
}

#sig linForkSync : forall s::Session,e::Row.((s) ~e~@ EndBang) ~e~> ~s
sig linForkSync : forall s::Session,e::Row.((s) {SessionFail:() =@ [||]}~@ EndBang) ~e~> ~s
fun linForkSync(f) {
  xlin;
  var ap = new();
  var _ = spawn {
    var c = accept(ap);
    var c = f(c);
    closeBang(c)
  };
  request(ap)
}

#sig linkSync : forall s::Session,e::Row.(s, ~s) ~e~> EndBang
sig linkSync : forall s::Session,e::Row.(s, ~s) {SessionFail:() =@ [||] | e}~> EndBang
fun linkSync(s, c) {
  xlin;
  link(s, c);
  makeEndBang()
}

#sig runSync : ((!a.EndBang) ~e~> EndBang) ~e~> a
sig runSync : forall a, e::Row . ((!a.EndBang) {SessionFail:() =@ [||]}~> EndBang) { |e}~> a
fun runSync(f) {
  xlin;
  var c = forkSync(f);
  var (v, c) = receive(c);
  wait(c);
  v
}
### end of sessions with split ends ###

####
