infixl 6 +;
infixl 7 *;

typename Nat = [|Zero|Succ:Nat|];

#class Base2;

#class Record : (a::Eff) {
#		sig + : (a, a) -> a;
#}

# In this case the operator + takes on the kind Numeric.
class Num : (a::Base) {
		sig + : (a, a) -> a;
		sig * : (a, a) -> a;
		sig `negate` : (a) -> a;
}

infix 4 ==;
infix 4 <>;

#class Eq : (a) {
#		sig == : (a, a) -> a;
#		sig <> : (a, a) -> a;
#}

instance Num : Int {
		+ : addInt;
		* : mulInt;
		`negate` : negInt;
}

#instance Num : Nat {
#		+ : addNat;
#		* : mulNat;
#		`negate` : negNat;
#}

#instance Eq : Int {
#		== : eqInt;
#}


sig dummy : (a::Num) -> a
fun dummy (x) {
		x
}


sig square : (a::Num) -> a
fun square(x) {
		x * x
}

class Show : (a::Type) {
		sig `show` : (a) ~> String;
}

instance Show : Bool {
		# Not supported yet, check transformSugar
		#`show` : fun (x) { if (x == true) "True" else "False" };
		`show` : boolToString;
}


2 + 2

# Sees that + is already defined with a kind signature, now has
# to update the signature to refelect a wider quantifier.
# 
# If + wants be used by both Strings and Numeric then 
# NOTE: lazy as fuck
# we will lazily say that the subkind is Mono, as Mono can 
# unify with any subkind.
# If instead...
#class SmallNums : (a::Num) {
#		sig + : (a, a) -> a;
#}

# Then we identify that this new sk is a subkind of the current sig
# So we do nothing.

# Updates the constraint associated with the restriction "Numeric" to 
# accept of type Int.


#instance Num : Float {
#		negate : negFloat;
#}

