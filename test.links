infixl 6 +;
#infixl 7 *;

typename Nat = [|Zero|Succ:Nat|];

# In this case the operator + takes on the kind Numeric.
class Num : (a) {
		sig + : (a, a) -> a;
}

instance Num : Int {
		+ : addInt;
}

op m + n {
		n
}

#sig test : (a::Num) -> a
#fun test(x) { x }

#test(2)

2 + 2


# Sees that + is already defined with a kind signature, now has
# to update the signature to refelect a wider quantifier.
# 
# If + wants be used by both Strings and Numeric then 
# NOTE: lazy as fuck
# we will lazily say that the subkind is Mono, as Mono can 
# unify with any subkind.
# If instead...
#class SmallNums : (a::Num) {
#		sig + : (a, a) -> a;
#}

# Then we identify that this new sk is a subkind of the current sig
# So we do nothing.

# Updates the constraint associated with the restriction "Numeric" to 
# accept of type Int.


#instance Num : Float {
#		negate : negFloat;
#}

#sig square : (a::Num) -> a
#fun square(x) {
#		x * x
#}

