infixl 6 +;
#infixl 7 *;

# In this case the operator + takes on the kind Numeric.
class Num : (a) {
		sig + : (a, a) -> a;
#		sig * : (a, a) -> a;
}

# Sees that + is already defined with a kind signature, now has
# to update the signature to refelect a wider quantifier.
# 
# If + wants be used by both Strings and Numeric then 
# NOTE: lazy as fuck
# we will lazily say that the subkind is Mono, as Mono can 
# unify with any subkind.
# If instead...
#class SmallNums : (a::Num) {
#		sig + : (a, a) -> a;
#}

# Then we identify that this new sk is a subkind of the current sig
# So we do nothing.

# Updates the constraint associated with the restriction "Numeric" to 
# accept of type Int.
#instance Num : Int {
#		+ : addInt;
		#negate : negInt;
#}

#instance Num : Float {
#		negate : negFloat;
#}

#sig square : (a::Num) -> a
#fun square(x) {
#		x * x
#}
