

sig square : (a::Num) -> a
fun square(x) {
		x * x
}

sig squares : (a::Num, a, a) -> (a, a, a)
fun squares (x, y, z) {
		(square(x), square(y), square(z))
}

`show` false


# Sees that + is already defined with a kind signature, now has
# to update the signature to refelect a wider quantifier.
# 
# If + wants be used by both Strings and Numeric then 
# NOTE: lazy as fuck
# we will lazily say that the subkind is Mono, as Mono can 
# unify with any subkind.
# If instead...
#class SmallNums : (a::Num) {
#		sig + : (a, a) -> a;
#}

# Then we identify that this new sk is a subkind of the current sig
# So we do nothing.

# Updates the constraint associated with the restriction "Numeric" to 
# accept of type Int.
